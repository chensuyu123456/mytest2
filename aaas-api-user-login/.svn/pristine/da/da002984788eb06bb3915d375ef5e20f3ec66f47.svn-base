package com.shellshellfish.account.service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.validation.ConstraintViolationException;

import java.util.Date;
import java.sql.Timestamp;

import org.springframework.test.context.ActiveProfiles;

import org.springframework.beans.factory.annotation.Autowired;

import com.shellshellfish.account.commons.MD5;
import com.shellshellfish.account.exception.UserException;
import com.shellshellfish.account.model.Account;
import com.shellshellfish.account.model.User;
import com.shellshellfish.account.repositories.SmsVerificationRepositoryCustom;
import com.shellshellfish.account.repositories.UserRepository;

@ActiveProfiles(profiles = "prod")
public class AccountServiceImpl implements AccountService {

	@Autowired
    private UserRepository userRepository;

	@Autowired
	private SmsVerificationRepositoryCustom smsVerificationRepositoryCustom;
	
	@Override
	public List<Account> findAllAccounts(String type, int pageSize, int stPos) {
		// TODO replace with database find_all operation
		
		List<Account> accounts = new ArrayList<Account>();
		/*
		
		for (int x = 0; x < pageSize; x++) {
		    Account account = new Account();
		    account.setName("Test" + (x+1));
		    account.setType(type);
		    account.setId(stPos+x);
		    accounts.add(account);
		}*/
		return accounts;
	}

	@Override
	public Account findById(long id) {
		// TODO replace with database find operation
		
		Account account = new Account();
		//account.setPassword("");
		//account.setTelnum("Fixed");
		account.setId(id);
		return account;
	}

	@Override
	public long createAccount(Account account) {
		// TODO create in DB and get new id
		return 100;
	}

	@Override
	public Account updateAccount(Account account) {
		// TODO update in DB
		return account;
	}

	@Override
	public Account deleteById(long id) {
		Account account = findById(id);
		// TDO delete from DB
		return account;
	}

	@Override
	public Map<String, Object> operate(Account account, Map<String, Object> request) {
		// TODO
		request.put("result", "processed");
		request.put("account", account);
		return request;
	}
	
	@Override
	public boolean isRegisteredUser(String cellphone, String passwordhash) {
		if (userRepository.findByCellPhoneAndPasswordHash(cellphone, passwordhash)!=null)
			return true;
		return false;
	}
	
	@Override
	public boolean isSettingPWD(String id, String pwdsetting, String pwdconfirm) {
		if (pwdsetting.equals(pwdconfirm)) {
			Pattern p = Pattern.compile(
					"^(?![A-Za-z]+$)(?![A-Z\\d]+$)(?![A-Z\\W]+$)(?![a-z\\d]+$)(?![a-z\\W]+$)(?![\\d\\W]+$)\\S{8,20}$");
			Matcher m = p.matcher(pwdconfirm);
			if (m.find()) {
				User user = userRepository.findById(Long.valueOf(id));
				if (user == null) {
					throw new UserException("101", "用户不存在");
				}
				String currentPWD = user.getPasswordHash();
				String pwd = MD5.getMD5(pwdconfirm);
				if (currentPWD == null || currentPWD.equals(pwd)) {
					throw new UserException("101", "不可与原密码一致");
				}
				user.setPasswordHash(MD5.getMD5(pwdconfirm));
				Date date = new Date();
				Timestamp nowdate = new Timestamp(date.getTime());
				user.setLastModifiedDate(nowdate);
				userRepository.save(user);
				return true;
			} else {
				throw new UserException("101", "密码长度至少8位,至多16位，必须是字母 大写、字母小写、数字、特殊字符中任意三种组合");
			}
		} else {
			throw new UserException("101", "两次密码必须一致");
		}
	}
	
	@Override
	public boolean isRegisterredTel(String cellphone) {
		List<User> reslst=userRepository.findByCellPhone(cellphone);
		if (reslst.size()>0)
			return true;
		
		return false;		
	}
	
	@Override
	public boolean isSmsVerified(String cellphone,String verfiedcode) {
		List<Object[]> reslst=smsVerificationRepositoryCustom.getSmsVerification(cellphone, verfiedcode);
		if (reslst.size()>0)
			return true;
		
		return false;
		
	}
}
